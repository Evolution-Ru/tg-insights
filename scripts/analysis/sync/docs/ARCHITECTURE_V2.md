# Архитектура синхронизации Telegram ↔ Asana V2

## Проблемы текущей реализации

1. **Эмбеддинги используются как финальное решение**, а не как подготовительный этап
2. **Нет учета временных окон** - все задачи сравниваются со всеми без учета контекста времени
3. **Не используется кеш OpenAI** для эмбеддингов (более дешевый вариант)
4. **GPT-5 вызывается для всех потенциальных совпадений**, даже когда можно обойтись эмбеддингами

## Новая концепция: Многоуровневое сопоставление с временными окнами

### Принципы

1. **Эмбеддинги = подготовительный этап** для сужения круга кандидатов
2. **Временные окна** для определения релевантного контекста сопоставления
3. **Кеш OpenAI** для переиспользования эмбеддингов
4. **Многоуровневый анализ**: эмбеддинги → временное окно → GPT-5 для топ-кандидатов

## Алгоритм

### Этап 1: Определение временного окна для Telegram задачи

**Входные данные:**
- Telegram задача с контекстом (даты сообщений из `context`)
- Дата первого упоминания задачи в переписке

**Процесс:**
1. Извлекаем даты из `context` задачи Telegram
2. Определяем временное окно:
   - **Основное окно**: ±7 дней от первой даты упоминания
   - **Расширенное окно**: ±30 дней (для проверки с более низким приоритетом)
   - **Дальние окна**: ±90 дней (для проверки с минимальным приоритетом)

**Пример:**
```
Telegram задача упомянута: 2024-08-20
Основное окно: 2024-08-13 - 2024-08-27 (тщательный анализ)
Расширенное окно: 2024-07-21 - 2024-09-19 (краткий анализ)
Дальнее окно: 2024-05-22 - 2024-11-18 (минимальный анализ)
```

### Этап 2: Фильтрация задач Asana по временным окнам

**Процесс:**
1. Загружаем все задачи Asana с полями `created_at`, `modified_at`
2. Для каждой Telegram задачи:
   - Фильтруем задачи Asana по временным окнам
   - Приоритизируем: основное окно > расширенное > дальнее

**Результат:**
- Основное окно: ~5-10 задач (тщательный анализ)
- Расширенное окно: ~20-30 задач (краткий анализ)
- Дальнее окно: ~50-100 задач (минимальный анализ)

### Этап 3: Подготовительный поиск через эмбеддинги (с кешем)

**Процесс:**
1. **Используем кеш OpenAI** для эмбеддингов (если доступен)
2. Создаем эмбеддинги для задач Asana в основном окне (батчами)
3. Создаем эмбеддинг для Telegram задачи
4. Вычисляем косинусное сходство со всеми задачами в окне
5. Сортируем по убыванию score

**Результат:**
- Топ-3 кандидата из основного окна (score >= 0.60)
- Топ-5 кандидатов из расширенного окна (score >= 0.65)
- Топ-10 кандидатов из дальнего окна (score >= 0.70)

### Этап 4: Детальный анализ через GPT-5

**Процесс:**
1. Для каждого топ-кандидата:
   - Если score >= 0.75 → совпадение найдено ✅
   - Если 0.65 <= score < 0.75 → GPT-5 проверка
   - Если score < 0.65 → пропускаем

2. **GPT-5 проверка** (только для потенциальных совпадений):
   - Загружаем полный контекст задачи Asana (notes, история)
   - Сравниваем с Telegram задачей через GPT-5
   - Если GPT-5 подтверждает (score >= 0.75) → совпадение ✅

**Результат:**
- Финальный список совпадений с оценками

## Оптимизация затрат

### Использование кеша OpenAI

**OpenAI предоставляет кеш для эмбеддингов:**
- Кеш дешевле обычных запросов (~50% экономии)
- Переиспользование эмбеддингов для одинаковых текстов
- Автоматическое обновление при изменении текста

**Реализация:**
```python
# Используем параметр cache_control для кеширования
response = client.embeddings.create(
    model="text-embedding-3-small",
    input=texts,
    cache_control={"type": "ephemeral"}  # или "persistent"
)
```

### Локальные эмбеддинги

**Для часто используемых задач:**
- Сохраняем эмбеддинги локально в JSON
- Переиспользуем при повторных запусках
- Обновляем только при изменении текста задачи

**Реализация:**
```python
# Проверяем локальный кеш перед запросом к API
if task_text_hash in local_cache:
    embedding = local_cache[task_text_hash]
else:
    embedding = get_embedding_with_cache(task_text)
    local_cache[task_text_hash] = embedding
```

### Оптимизация GPT-5 вызовов

**Текущая проблема:** GPT-5 вызывается для всех потенциальных совпадений

**Решение:**
1. Используем эмбеддинги для предварительной фильтрации
2. GPT-5 только для топ-3 кандидатов из основного окна
3. Для расширенного/дальнего окна - только если score очень высокий (>= 0.75)

**Экономия:**
- Было: ~20 GPT-5 вызовов на задачу
- Стало: ~3-5 GPT-5 вызовов на задачу
- Экономия: ~75%

## Структура данных

### Telegram задача (расширенная)

```json
{
  "title": "Название задачи",
  "description": "Описание",
  "assignee": "Кто выполняет",
  "deadline": "2024-08-25",
  "status": "в процессе",
  "chats": ["Чат1", "Чат2"],
  "discussion_thread": "Ветка обсуждения",
  "context": "Фрагмент переписки",
  "dates": {
    "first_mentioned": "2024-08-20",
    "last_mentioned": "2024-08-22",
    "all_dates": ["2024-08-20", "2024-08-21", "2024-08-22"]
  },
  "time_window": {
    "primary": {"from": "2024-08-13", "to": "2024-08-27"},
    "extended": {"from": "2024-07-21", "to": "2024-09-19"},
    "distant": {"from": "2024-05-22", "to": "2024-11-18"}
  }
}
```

### Asana задача (расширенная)

```json
{
  "gid": "123456",
  "name": "Название",
  "notes": "Описание",
  "created_at": "2024-08-15T10:00:00Z",
  "modified_at": "2024-08-25T14:30:00Z",
  "completed": false,
  "embedding": [0.1, 0.2, ...],  // Кешированный эмбеддинг
  "embedding_hash": "abc123",    // Хеш текста для кеша
  "time_window_match": "primary" // В какое окно попадает
}
```

## Реализация

### Класс `TimeWindowMatcher`

```python
class TimeWindowMatcher:
    """Менеджер временных окон для сопоставления задач"""
    
    def calculate_time_windows(self, first_date: str) -> Dict[str, Dict]:
        """Вычисляет временные окна для задачи"""
        # Основное окно: ±7 дней
        # Расширенное окно: ±30 дней
        # Дальнее окно: ±90 дней
    
    def filter_tasks_by_window(
        self, 
        asana_tasks: List[Dict], 
        window: Dict[str, str]
    ) -> List[Dict]:
        """Фильтрует задачи Asana по временному окну"""
        # Фильтруем по created_at или modified_at
```

### Класс `EmbeddingCache`

```python
class EmbeddingCache:
    """Менеджер кеша эмбеддингов"""
    
    def get_embedding(
        self, 
        text: str, 
        use_openai_cache: bool = True,
        use_local_cache: bool = True
    ) -> List[float]:
        """Получает эмбеддинг с использованием кеша"""
        # 1. Проверяем локальный кеш
        # 2. Если нет - запрашиваем с OpenAI cache
        # 3. Сохраняем в локальный кеш
```

### Обновленный `AsanaSync.find_matching_tasks`

```python
def find_matching_tasks(
    self,
    telegram_tasks: List[Dict],
    asana_tasks: List[Dict],
    use_time_windows: bool = True,
    use_embedding_cache: bool = True,
    similarity_threshold: float = 0.75
) -> Dict:
    """Многоуровневое сопоставление с временными окнами"""
    
    # 1. Определяем временные окна для каждой Telegram задачи
    # 2. Фильтруем задачи Asana по окнам
    # 3. Создаем эмбеддинги с кешем (основное окно)
    # 4. Предварительный поиск через эмбеддинги
    # 5. GPT-5 проверка для топ-кандидатов
```

## Преимущества новой архитектуры

1. **Качество:** Временные окна обеспечивают релевантный контекст
2. **Скорость:** Меньше сравнений за счет фильтрации по окнам
3. **Затраты:** Кеш OpenAI + локальный кеш + меньше GPT-5 вызовов
4. **Точность:** Многоуровневый анализ повышает точность сопоставления

## Оценка затрат

### Текущая реализация (21 Telegram × 100 Asana)
- Эмбеддинги: ~$0.002 (100 задач Asana)
- GPT-5: ~$20-50 (20 проверок × 21 задача)
- **Итого: ~$20-50**

### Новая реализация (21 Telegram × ~10-30 Asana в окне)
- Эмбеддинги с кешем: ~$0.001 (кеш дешевле на 50%)
- GPT-5: ~$5-10 (3-5 проверок × 21 задача)
- **Итого: ~$5-10**
- **Экономия: ~75%**

## План внедрения

1. ✅ Создать класс `TimeWindowMatcher`
2. ✅ Создать класс `EmbeddingCache`
3. ✅ Обновить `AsanaSync.find_matching_tasks`
4. ✅ Добавить извлечение дат из контекста Telegram задач
5. ✅ Интегрировать кеш OpenAI для эмбеддингов
6. ✅ Тестирование на реальных данных
7. ✅ Оптимизация порогов и параметров окон

